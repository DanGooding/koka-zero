open! Core
open! Import

module Phi_builder : sig
  type 'a t = ('a * Llvm.llbasicblock) list -> 'a Codegen.t

  val llvalue : Llvm.llvalue t
end

module Compile_conditional : sig
  type 'a t =
    cond_i1:Llvm.llvalue
    -> compile_true:(unit -> 'a Codegen.t)
    -> compile_false:(unit -> 'a Codegen.t)
    -> 'a Codegen.t

  (** [compile_conditional cond ~compile_true ~compile_false ~phi_builder] generates a branch
      based on the value of [i1] [cond], to either the code of [compile_true] or
      [compile_false], then generates a phi node to combine their values *)
  val recombining : phi_builder:'a Phi_builder.t -> 'a t

  (** builds a conditional where each branch is expected to contain a [return],
      so no subsequent recombining block is added. *)
  val tail_position : unit t
end

module Compile_switch : sig
  type 'a t =
    Llvm.llvalue
    -> table:(Llvm.llvalue * string * (unit -> 'a Codegen.t)) list
    -> compile_default:(unit -> 'a Codegen.t)
    -> 'a Codegen.t

  (** [compile_switch case ~table ~compile_default ~phi_builder] builds a switch statement,
      branching on the valule of [case], to either a branch in [table], or the
      default. Each branch is given as [(tag, name, compile_branch)] where the
      code generated by [compile_branch] is jumped to if [case] matches [tag].
      The branch results are recombined with [compile_phi]. *)
  val recombining : phi_builder:'a Phi_builder.t -> 'a t

  val tail_position : unit t
end
