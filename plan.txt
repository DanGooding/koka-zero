https://lptk.github.io/programming/2020/03/26/demystifying-mlsub.html

[ ] de-duplicating bounds using sets

[ ] some add-hoc identities for Handled (e.g. Handled(labels, Labels(..)) or Handled(Handled(..)))
[ ] and for Intersection/Union (e.g. of empty/singleton)
[ ] how do I want to express "E does not contain <l>, but is otherwise unconstrained" in a type? 
- Lacks(l, F) for an unconstrained F

[ ] expansion gets a read-only view of the constraints?

[ ] try using negation types from https://www.irif.fr/~gc/papers/icalp-ppdp05.pdf
A - B  is A inter neg(B)

[ ] try getting rid of the type/effect metavaraible split - we know statically what is what.
[ ] avoid so much duplication between types & effects - e.g. the metavaraible expansion case
[ ] cleanup the interface of Type 
[ ] do we want to keep the Type vs Polar_type split?
[x] Name_source becomes mutable (then we can pass this around instead of passing functions)

[ ] cleanup inference: perhaps we do want to separate [t] from the actual mutually recursive functions

structure:

state:
expansion & inference
- variable+metavaraible name_source (for generalisation & extension)
- constraints on metavaraibles
inference only
- metavaraible levels
expansion only
- in-progress mappings

failure:
inference
- variable can be missing
- handler might not match signature

expansion
- none

simplification
- discover an empty intersection type


[ ] remove Variable from Type.Mono?

[] BUG? how does generalisation work if it's done before we apply any constraints?
- need extrude


current incorrect:
- gen: replace all meta >=local_level with fresh vars
- inst; replace those vars with fresh meta
this loses a bunch of constraints...


described:
- gen: just remember local_level
- inst: replace all meta >= local_level with fresh meta at the current level
  - fresh meta should have all their bounds freshened also

- constrain: if variable's bound is at a higher level, extrude the bound to it's level


so it seems like we could indeed freshen bounds only once
then the relevant meta with new meta (including in the bounds)
i.e. duplicating




[ ] should expansion cache each metavaraible's expansion?
