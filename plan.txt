https://lptk.github.io/programming/2020/03/26/demystifying-mlsub.html

[ ] de-duplicating bounds using sets

[ ] some add-hoc identities for Handled (e.g. Handled(labels, Labels(..)) or Handled(Handled(..)))
[ ] and for Intersection/Union (e.g. of empty/singleton)
[ ] how do I want to express "E does not contain <l>, but is otherwise unconstrained" in a type? 
- Lacks(l, F) for an unconstrained F

[ ] expansion gets a read-only view of the constraints?

[ ] try using negation types from https://www.irif.fr/~gc/papers/icalp-ppdp05.pdf
A - B  is A inter neg(B)

[ ] try getting rid of the type/effect metavaraible split - we know statically what is what.
[ ] avoid so much duplication between types & effects - e.g. the metavaraible expansion case
[ ] cleanup the interface of Type 
[ ] do we want to keep the Type vs Polar_type split?
[x] Name_source becomes mutable (then we can pass this around instead of passing functions)

[ ] cleanup inference: perhaps we do want to separate [t] from the actual mutually recursive functions

structure:

state:
expansion & inference
- variable+metavaraible name_source (for generalisation & extension)
- constraints on metavaraibles
inference only
- metavaraible levels
expansion only
- in-progress mappings

failure:
inference
- variable can be missing
- handler might not match signature

expansion
- none

simplification
- discover an empty intersection type


[ ] combine level & bounds for each metavariable into a single hashtable

[ ] remove Variable from Type.Mono?


[ ] should expansion cache each metavaraible's expansion?
[ ] bounds should not use camelCase

[ ] add_binding function which supports parameters & shadowing errors